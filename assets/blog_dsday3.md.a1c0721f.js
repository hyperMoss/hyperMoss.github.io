import{o as n,c as s,a,b as p,e as t,d as o}from"./app.9d0c7254.js";const e='{"title":"树","description":"","frontmatter":{"title":"树","date":"2019-01-08 20:15:55"},"headers":[{"level":2,"title":"树的基本概念","slug":"树的基本概念"},{"level":3,"title":"树的定义","slug":"树的定义"},{"level":3,"title":"树的性质","slug":"树的性质"},{"level":2,"title":"树的存储结构","slug":"树的存储结构"},{"level":3,"title":"顺序存储结构","slug":"顺序存储结构"},{"level":2,"title":"二叉树","slug":"二叉树"},{"level":3,"title":"特殊二叉树","slug":"特殊二叉树"},{"level":3,"title":"二叉树的性质","slug":"二叉树的性质"},{"level":2,"title":"二叉树的存储结构","slug":"二叉树的存储结构"},{"level":3,"title":"顺序存储","slug":"顺序存储"},{"level":3,"title":"链式存储","slug":"链式存储"},{"level":2,"title":"二叉树的遍历（递归）","slug":"二叉树的遍历（递归）"},{"level":3,"title":"递归先序遍历","slug":"递归先序遍历"},{"level":3,"title":"递归中序遍历","slug":"递归中序遍历"},{"level":3,"title":"递归后序遍历","slug":"递归后序遍历"},{"level":2,"title":"二叉树的遍历（非递归）","slug":"二叉树的遍历（非递归）"},{"level":3,"title":"非递归先序遍历","slug":"非递归先序遍历"},{"level":3,"title":"非递归中序遍历","slug":"非递归中序遍历"},{"level":3,"title":"非递归后序遍历","slug":"非递归后序遍历"},{"level":3,"title":"层序遍历","slug":"层序遍历"},{"level":2,"title":"线索二叉树","slug":"线索二叉树"},{"level":2,"title":"哈夫曼树和哈夫曼编码","slug":"哈夫曼树和哈夫曼编码"}],"relativePath":"blog/dsday3.md","lastUpdated":1640015528977}',c={},l=p("h1",{id:"树"},[p("a",{class:"header-anchor",href:"#树","aria-hidden":"true"},"#"),t(" 树")],-1),u=p("h2",{id:"树的基本概念"},[p("a",{class:"header-anchor",href:"#树的基本概念","aria-hidden":"true"},"#"),t(" 树的基本概念")],-1),k=o('<h3 id="树的定义"><a class="header-anchor" href="#树的定义" aria-hidden="true">#</a> 树的定义</h3><p>树是N（N≥0）个结点的有限集合，N=0时，称为空树，是一种特殊情况。在任意一棵非空树中应满足：</p><ul><li><p>有且仅有一个特定的称为根的结点。</p></li><li><p>当N&gt;1时，其余结点可分为m（m&gt;0）</p></li></ul><p>个互不相交的有限集合T1，T2，…，Tm， 其中每一个集合本身又是一棵树，并且 称为根结点的子树。</p><h3 id="树的性质"><a class="header-anchor" href="#树的性质" aria-hidden="true">#</a> 树的性质</h3><ul><li><p>树中的结点数等于所有结点的度数加1。</p></li><li><p>度为m的树中第i层上至多有mi−1个结点（i≥1）。</p></li><li><p>高度为h的m叉树至多有(mh</p></li></ul><p>-1)/(m-1)个结点</p><h2 id="树的存储结构"><a class="header-anchor" href="#树的存储结构" aria-hidden="true">#</a> 树的存储结构</h2><h3 id="顺序存储结构"><a class="header-anchor" href="#顺序存储结构" aria-hidden="true">#</a> 顺序存储结构</h3><h4 id="双亲表示法"><a class="header-anchor" href="#双亲表示法" aria-hidden="true">#</a> 双亲表示法</h4><p>双亲表示法：用一组连续的存储空间存储树的结点，同时在每个结点中，用一个变量存储该结点的双亲结点在数组中的位置。</p><div class="language-c"><pre><code><span class="token keyword">typedef</span> <span class="token keyword">char</span> ElemType<span class="token punctuation">;</span>\n<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">TNode</span><span class="token punctuation">{</span>\nElemType data<span class="token punctuation">;</span> <span class="token comment">//结点数据</span>\n<span class="token keyword">int</span> parent<span class="token punctuation">;</span> <span class="token comment">//该结点双亲在数组中的下标</span>\n<span class="token punctuation">}</span>TNode<span class="token punctuation">;</span> <span class="token comment">//结点数据类型</span>\ndata parent\n结点类型\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Maxsize</span> <span class="token expression"><span class="token number">100</span></span></span>\n<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>\nTNode nodes<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//结点数组</span>\n<span class="token keyword">int</span> n<span class="token punctuation">;</span> <span class="token comment">//结点数量</span>\n<span class="token punctuation">}</span>Tree<span class="token punctuation">;</span> <span class="token comment">//树的双亲表示结构</span>\n</code></pre></div><h4 id="孩子表示法"><a class="header-anchor" href="#孩子表示法" aria-hidden="true">#</a> 孩子表示法</h4><p>把每个结点的孩子结点排列起来存储成一个单链表。所以n个结点就有n个链表； 如果是叶子结点，那这个结点的孩子单链表就是空的； 然后n个单链表的的头指针又存储在一个顺序表（数组）中。</p><div class="language-c"><pre><code><span class="token keyword">typedef</span> <span class="token keyword">char</span> ElemType<span class="token punctuation">;</span>\n<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CNode</span><span class="token punctuation">{</span>\n<span class="token keyword">int</span> child<span class="token punctuation">;</span> <span class="token comment">//该孩子在表头数组的下标</span>\n<span class="token keyword">struct</span> <span class="token class-name">CNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">//指向该结点的下一个孩子结点</span>\n<span class="token punctuation">}</span>CNode，<span class="token operator">*</span>Child<span class="token punctuation">;</span> <span class="token comment">//孩子结点数据类型</span>\n<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>\nElemtype data<span class="token punctuation">;</span> <span class="token comment">//结点数据域</span>\nChild firstchild<span class="token punctuation">;</span> <span class="token comment">//指向该结点的第一个孩子结点</span>\n<span class="token punctuation">}</span>TNode<span class="token punctuation">;</span> <span class="token comment">//孩子结点数据类型</span>\n\n</code></pre></div><h4 id="孩子兄弟表示法"><a class="header-anchor" href="#孩子兄弟表示法" aria-hidden="true">#</a> 孩子兄弟表示法</h4><p>孩子兄弟表示法：顾名思义就是要存储孩子和孩子结点的兄弟，具体来说，就是设置两个指针，分别指向该结 点的第一个孩子结点和这个孩子结点的右兄弟结点。</p><div class="language-c"><pre><code><span class="token keyword">typedef</span> <span class="token keyword">char</span> ElemType<span class="token punctuation">;</span>\n<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CSNode</span><span class="token punctuation">{</span>\nElemType data<span class="token punctuation">;</span> <span class="token comment">//该结点的数据域</span>\n<span class="token keyword">struct</span> <span class="token class-name">CSNode</span> <span class="token operator">*</span>firstchild<span class="token punctuation">,</span><span class="token operator">*</span>rightsib<span class="token punctuation">;</span> <span class="token comment">//指向该结点的第一个孩子结点和该结点的右兄弟结点</span>\n<span class="token punctuation">}</span>CSNode<span class="token punctuation">;</span>\n</code></pre></div><h2 id="二叉树"><a class="header-anchor" href="#二叉树" aria-hidden="true">#</a> 二叉树</h2><p>二叉树是n（n≥0）个结点的有限集合：</p><ul><li>或者为空二叉树，即n=0。</li><li>或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。</li></ul><p>二叉树的五种基本形态：</p><ul><li>空树</li><li>只有一个根结点</li><li>根结点只有左子树</li><li>根结点只有右子树</li><li>根结点既有左子树又有右子树</li></ul><h3 id="特殊二叉树"><a class="header-anchor" href="#特殊二叉树" aria-hidden="true">#</a> 特殊二叉树</h3><ul><li>斜树</li><li>满二叉树</li><li>完全二叉树</li></ul><h3 id="二叉树的性质"><a class="header-anchor" href="#二叉树的性质" aria-hidden="true">#</a> 二叉树的性质</h3><ul><li>非空二叉树上叶子结点数等于度为2的结点数加1</li><li>非空二叉树上第K层上至多有2k−1个结点（K≥1）</li><li>高度为H的二叉树至多有2H-1个结点（H≥1）</li><li>具有N个（N&gt;0）结点的完全二叉树的高度为 log2(N+1)或log2N+1。</li></ul><h2 id="二叉树的存储结构"><a class="header-anchor" href="#二叉树的存储结构" aria-hidden="true">#</a> 二叉树的存储结构</h2><h3 id="顺序存储"><a class="header-anchor" href="#顺序存储" aria-hidden="true">#</a> 顺序存储</h3><p>按层序遍历 存储在数组中</p><h3 id="链式存储"><a class="header-anchor" href="#链式存储" aria-hidden="true">#</a> 链式存储</h3><p>二叉树每个结点最多两个孩子，所以设计二叉树的结点结构时考虑两个指针指向该结点的两个孩子。</p><div class="language-c"><pre><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BiTNode</span><span class="token punctuation">{</span>\nElemType data<span class="token punctuation">;</span> <span class="token comment">//数据域</span>\n<span class="token keyword">struct</span> <span class="token class-name">BiTNode</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span><span class="token operator">*</span>rchild<span class="token punctuation">;</span> <span class="token comment">//指向该结点的左、右孩子指针</span>\n<span class="token punctuation">}</span>BiTNode<span class="token punctuation">,</span><span class="token operator">*</span>BiTree<span class="token punctuation">;</span> <span class="token comment">//二叉树结点结构</span>\n</code></pre></div><h2 id="二叉树的遍历（递归）"><a class="header-anchor" href="#二叉树的遍历（递归）" aria-hidden="true">#</a> 二叉树的遍历（递归）</h2><h3 id="递归先序遍历"><a class="header-anchor" href="#递归先序遍历" aria-hidden="true">#</a> 递归先序遍历</h3><p>ROOT LEFT RIGHT</p><div class="language-c"><pre><code><span class="token keyword">void</span> <span class="token function">PreOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>\n<span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n<span class="token function">printf</span><span class="token punctuation">(</span>“<span class="token operator">%</span>c”<span class="token punctuation">,</span>T<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span> <span class="token comment">//访问根结点</span>\n<span class="token function">PreOrder</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//递归遍历左子树</span>\n<span class="token function">PreOrder</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//递归遍历右子树</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="递归中序遍历"><a class="header-anchor" href="#递归中序遍历" aria-hidden="true">#</a> 递归中序遍历</h3><p>LEFT ROOT RIGHT</p><div class="language-c"><pre><code><span class="token keyword">void</span> <span class="token function">InOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>\n<span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n<span class="token function">InOrder</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//递归遍历左子树</span>\n<span class="token function">printf</span><span class="token punctuation">(</span>“<span class="token operator">%</span>c”<span class="token punctuation">,</span>T<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span>； <span class="token comment">//访问根结点</span>\n<span class="token function">InOrder</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//递归遍历右子树</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="递归后序遍历"><a class="header-anchor" href="#递归后序遍历" aria-hidden="true">#</a> 递归后序遍历</h3><p>LEFT RIGHT ROOT</p><div class="language-c"><pre><code><span class="token keyword">void</span> <span class="token function">PostOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>\n<span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n<span class="token function">PostOrder</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//递归遍历左子树</span>\n<span class="token function">PostOrder</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//递归遍历右子树</span>\n<span class="token function">printf</span><span class="token punctuation">(</span>“<span class="token operator">%</span>c”<span class="token punctuation">,</span>T<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span>； <span class="token comment">//访问根结点</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h2 id="二叉树的遍历（非递归）"><a class="header-anchor" href="#二叉树的遍历（非递归）" aria-hidden="true">#</a> 二叉树的遍历（非递归）</h2><h3 id="非递归先序遍历"><a class="header-anchor" href="#非递归先序遍历" aria-hidden="true">#</a> 非递归先序遍历</h3><p>ROOT LEFT RIGHT</p><div class="language-c"><pre><code>Void <span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>BiTree b<span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token function">InitStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    BiTree p<span class="token operator">=</span>b<span class="token punctuation">;</span> <span class="token comment">//工作指针p</span>\n    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n     <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>\n     <span class="token function">printf</span><span class="token punctuation">(</span>“<span class="token operator">%</span>c”<span class="token punctuation">,</span>p<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//先序先遍历结点</span>\n        <span class="token function">Push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//进栈保存</span>\n        p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>lchild<span class="token punctuation">;</span> \n         <span class="token punctuation">}</span>\n    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        p<span class="token operator">=</span><span class="token function">Pop</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>\n         p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>rchild<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="非递归中序遍历"><a class="header-anchor" href="#非递归中序遍历" aria-hidden="true">#</a> 非递归中序遍历</h3><p>LEFT ROOT RIGHT</p><div class="language-c"><pre><code>Void <span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>BiTree b<span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token function">InitStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    BiTree p<span class="token operator">=</span>b<span class="token punctuation">;</span> <span class="token comment">//工作指针p</span>\n    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//中序先将结点进栈保存</span>\n        <span class="token function">Push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>lchild<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> \n    <span class="token comment">//遍历到左下角尽头再出栈访问</span>\n    p<span class="token operator">=</span><span class="token function">Pop</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token function">printf</span><span class="token punctuation">(</span>“<span class="token operator">%</span>c”<span class="token punctuation">,</span>p<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>rchild<span class="token punctuation">;</span> <span class="token comment">//遍历右孩子</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="非递归后序遍历"><a class="header-anchor" href="#非递归后序遍历" aria-hidden="true">#</a> 非递归后序遍历</h3><p>LEFT RIGHT ROOT</p><div class="language-c"><pre><code>Void <span class="token function">PostOrderTraverse</span><span class="token punctuation">(</span>BiTree b<span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token function">InitStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    BiTree p<span class="token operator">=</span>b，r<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//工作指针p 辅助指针r</span>\n     <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token comment">//1.从根结点到最左下角的左子树都入栈</span>\n    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span> \n        <span class="token function">Push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>lchild<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> \n    <span class="token comment">//2.返回栈顶的两种情况</span>\n    <span class="token keyword">else</span><span class="token punctuation">{</span>\n        <span class="token function">GetTop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//取栈顶 注意不是出栈！</span>\n    <span class="token comment">//①右子树还未访问，而且右子树不空，第一次栈顶</span>\n        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>rchild <span class="token operator">&amp;&amp;</span>p<span class="token operator">-&gt;</span>rchild <span class="token operator">!=</span>r<span class="token punctuation">)</span> p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>rchild<span class="token punctuation">;</span>\n    <span class="token comment">//②右子树已经访问或为空，接下来出栈访问结点</span>\n    <span class="token keyword">else</span><span class="token punctuation">{</span>\n        <span class="token function">Pop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token function">printf</span><span class="token punctuation">(</span>“<span class="token operator">%</span>c”<span class="token punctuation">,</span>p<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        r<span class="token operator">=</span>p<span class="token punctuation">;</span> <span class="token comment">//指向访问过的右子树根结点</span>\n        p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//使p为空从而继续访问栈顶</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n</code></pre></div><h3 id="层序遍历"><a class="header-anchor" href="#层序遍历" aria-hidden="true">#</a> 层序遍历</h3><div class="language-c"><pre><code><span class="token keyword">void</span> <span class="token function">LevelOrder</span><span class="token punctuation">(</span>BiTree b<span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token function">InitQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    BiTree p<span class="token punctuation">;</span>\n    <span class="token function">EnQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//根结点进队</span>\n        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//队列不空循环</span>\n        <span class="token function">DeQueue</span><span class="token punctuation">(</span>Q，p<span class="token punctuation">)</span> <span class="token comment">//队头元素出队</span>\n        <span class="token function">printf</span><span class="token punctuation">(</span>“<span class="token operator">%</span>c”<span class="token punctuation">,</span>p<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>lchild<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>\n            <span class="token function">EnQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>p<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>rchild<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>\n            <span class="token function">EnQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>p<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n</code></pre></div><h2 id="线索二叉树"><a class="header-anchor" href="#线索二叉树" aria-hidden="true">#</a> 线索二叉树</h2><p>定义</p><div class="language-c"><pre><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ThreadNode</span><span class="token punctuation">{</span>\nElemType data<span class="token punctuation">;</span>\n<span class="token keyword">struct</span> <span class="token class-name">ThreadNode</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span><span class="token operator">*</span>rchild<span class="token punctuation">;</span>\n<span class="token keyword">int</span> ltag<span class="token punctuation">,</span>rtag<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>ThreadNode<span class="token punctuation">,</span><span class="token operator">*</span>ThreadTree<span class="token punctuation">;</span> <span class="token comment">//线索链表</span>\n</code></pre></div><p>构造</p><div class="language-c"><pre><code><span class="token keyword">void</span> <span class="token function">InThread</span><span class="token punctuation">(</span>ThreadTree <span class="token operator">&amp;</span>p<span class="token punctuation">,</span>ThreadTree <span class="token operator">&amp;</span>pre<span class="token punctuation">)</span><span class="token punctuation">{</span>\n<span class="token comment">//中序遍历对二叉树线索化的递归算法</span>\n <span class="token keyword">void</span> <span class="token function">InThread</span><span class="token punctuation">(</span>ThreadTree <span class="token operator">&amp;</span>p<span class="token punctuation">,</span>ThreadTree <span class="token operator">&amp;</span>pre<span class="token punctuation">)</span><span class="token punctuation">{</span>\n<span class="token comment">//中序遍历对二叉树线索化的递归算法</span>\n    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token function">InThread</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>lchild<span class="token punctuation">,</span>pre<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>lchild<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n            p<span class="token operator">-&gt;</span>lchild<span class="token operator">=</span>pre<span class="token punctuation">;</span>\n            p<span class="token operator">-&gt;</span>ltag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token keyword">if</span><span class="token punctuation">(</span>pre<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token operator">&amp;&amp;</span>pre<span class="token operator">-&gt;</span>rchild<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        pre<span class="token operator">-&gt;</span>rchild<span class="token operator">=</span>p<span class="token punctuation">;</span>\n        pre<span class="token operator">-&gt;</span>rtag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    pre<span class="token operator">=</span>p<span class="token punctuation">;</span>\n    <span class="token function">InThread</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>rchild<span class="token punctuation">,</span>pre<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>遍历</p><div class="language-c"><pre><code><span class="token keyword">void</span> <span class="token function">InOrderTraverse</span><span class="token punctuation">(</span>ThreadTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>\n    ThreadTree p<span class="token operator">=</span>T；\n    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>ltag<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>lchild<span class="token punctuation">;</span>\n            <span class="token function">printf</span><span class="token punctuation">(</span>“<span class="token operator">%</span>c”<span class="token punctuation">,</span>p<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>rtag<span class="token operator">==</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>p<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">{</span>\n            p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>rchild<span class="token punctuation">;</span>\n            <span class="token function">printf</span><span class="token punctuation">(</span>“<span class="token operator">%</span>c”<span class="token punctuation">,</span>p<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>rchild<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n</code></pre></div><h2 id="哈夫曼树和哈夫曼编码"><a class="header-anchor" href="#哈夫曼树和哈夫曼编码" aria-hidden="true">#</a> 哈夫曼树和哈夫曼编码</h2><p>算法的描述如下：</p><ol><li>将这N个结点分别作为N棵仅含一个结点的二叉树，构成森林F。</li><li>构造一个新结点，并从F中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和。</li><li>从F中删除刚才选出的两棵树，同时将新得到的树加入F中。</li><li>重复步骤2）和3），直至F中只剩下一棵树为止。</li></ol>',65);c.render=function(p,t,o,e,c,i){return n(),s("div",null,[l,u,a(" more "),k])};export default c;export{e as __pageData};
